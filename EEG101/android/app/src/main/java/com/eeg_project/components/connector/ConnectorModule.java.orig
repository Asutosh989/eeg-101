package com.eeg_project.components.connector;

<<<<<<< HEAD

import android.os.Handler;
import android.os.HandlerThread;
||||||| merged common ancestors
import android.app.Activity;
=======
import android.app.Activity;
import android.os.Handler;
import android.os.HandlerThread;
import android.os.Looper;
>>>>>>> dano-signal-processing
import android.support.annotation.Nullable;
import android.util.Log;

import com.choosemuse.libmuse.ConnectionState;
import com.choosemuse.libmuse.Muse;
import com.choosemuse.libmuse.MuseConnectionListener;
import com.choosemuse.libmuse.MuseConnectionPacket;
import com.choosemuse.libmuse.MuseListener;
import com.choosemuse.libmuse.MuseManagerAndroid;
import com.eeg_project.MainApplication;
import com.facebook.react.bridge.Arguments;
import com.facebook.react.bridge.Promise;
import com.facebook.react.bridge.ReactApplicationContext;
import com.facebook.react.bridge.ReactContext;
import com.facebook.react.bridge.ReactContextBaseJavaModule;
import com.facebook.react.bridge.ReactMethod;
import com.facebook.react.bridge.WritableMap;
import com.facebook.react.modules.core.DeviceEventManagerModule;

import java.util.List;
<<<<<<< HEAD
||||||| merged common ancestors
import java.util.Map;

/**
 * React Native Module that allows LibMuse functions related to searching for and connecting to Muse
 * devices to be called from JS
 */
=======
import java.util.Map;

>>>>>>> dano-signal-processing

<<<<<<< HEAD
// React Native module that handles connecting to Muses with LibMuse functions
// Calling getAndConnectToDevice from JS handles entire connection process.
public class ConnectorModule extends ReactContextBaseJavaModule {
||||||| merged common ancestors
public class ConnectorModule extends ReactContextBaseJavaModule {
=======
>>>>>>> dano-signal-processing

<<<<<<< HEAD
||||||| merged common ancestors

=======
// React Native module that allows app to connect to Muse devices.
// Calling getAndConnectToDevice from JS handles entire connection process.
public class ConnectorModule extends ReactContextBaseJavaModule {

>>>>>>> dano-signal-processing
    // ----------------------------------------------------------
    // Variables
    private final String TAG = "Connector";
    private MuseManagerAndroid manager;
    private ConnectionListener connectionListener;
    private int museIndex = 0;
    private int tryCount = 0;
    private List<Muse> availableMuses;
    private Promise connectionPromise;
    private Boolean isPromiseUnfulfilled;
    private Muse muse;
    public MainApplication appState;
    public Handler connectHandler;
    public HandlerThread connectThread;

    // ---------------------------------------------------------
    // Constructor
    public ConnectorModule(ReactApplicationContext reactContext) {
        super(reactContext);
    }

    // ---------------------------------------------------------
    // React Native Module methods
    // Required by ReactContextBaseJavaModule
    @Override
    public String getName() {
        return "Connector";
    }

    // Called to emit events to event listeners in JS
    private void sendEvent(ReactContext reactContext, String eventName, @Nullable WritableMap params) {
        reactContext
                .getJSModule(DeviceEventManagerModule.RCTDeviceEventEmitter.class)
                .emit(eventName, params);
    }

    // ------------------------------------------------------------
    // Bridged methods

    // Gets a list of devices and attempts to connect to them in sequence. Returns true if connected and false if no devices are detected
    @ReactMethod
<<<<<<< HEAD
    public void getAndConnectToDevice(Promise promise) {
        connectionPromise = promise;
        isPromiseUnfulfilled = true;

        if (manager == null) {
            startMuseManager();
        }
||||||| merged common ancestors
    public void startConnector() {

        // We need to set the context on MuseManagerAndroid before we can do anything.
        // This must come before other LibMuse API calls as it also loads the library.
        manager = MuseManagerAndroid.getInstance();
        manager.setContext(this.getReactApplicationContext());

        // Clear the list of available muses so the user sees an empty list of devices when starting
        availableMuses = null;

        appState = ((MainApplication)this.getCurrentActivity().getApplication());
=======
    public void getAndConnectToDevice(Promise promise) {
        sendEvent(getReactApplicationContext(), "DISCONNECTED", Arguments.createMap());
        connectionPromise = promise;
        isPromiseUnfulfilled = true;
        availableMuses = null;
        // Connected Muses are stored in the MainApplication context so they can be accessed from anywhere in the app.
        //Initializes the MainApplication content so that the connectedMuse object stored within the global application state and be accessed by any part of the app
        appState = ((MainApplication)this.getCurrentActivity().getApplication());
        if (manager == null) {
            startMuseManager();
        }
>>>>>>> dano-signal-processing

<<<<<<< HEAD
        // Connection and Muse search attempts are queued to a HandlerThread to handle synchrony
        connectThread = new HandlerThread("connectThread");
        connectThread.start();
        connectHandler = new Handler(connectThread.getLooper());
||||||| merged common ancestors
=======
        connectThread = new HandlerThread("connectThread");
        connectThread.start();
        connectHandler = new Handler(connectThread.getLooper());
        connectHandler.post(searchRunnable);
        connectToMuse();
        }
>>>>>>> dano-signal-processing

<<<<<<< HEAD
        // Queue one Muse search attempt
        connectHandler.post(searchRunnable);
||||||| merged common ancestors
=======
    //--------------------------------------------------------------
    // Internal methods
>>>>>>> dano-signal-processing

<<<<<<< HEAD
        // Start connection attempts
        connectToMuse();
        }

    //--------------------------------------------------------------
    // Internal methods

    // Starts the LibMuse MuseManagerAndroid class and creates a Muse Listener
    public void startMuseManager() {
        // MuseManagerAndroid must be created and given context before any LibMuse calls can be made
        manager = MuseManagerAndroid.getInstance();
        manager.setContext(this.getReactApplicationContext());
        // Listeners are attached to a weak reference to the current activity to avoid memory leaks
||||||| merged common ancestors
        // Todo: figure out if weakReference is necessary or desirable. get currentActivity might be good enough
        WeakReference<Activity> weakActivity =
                new WeakReference<Activity> (this.getCurrentActivity());

        // Register a listener to receive connection state changes.
        connectionListener = new ConnectionListener(weakActivity);

        // Register a listener to receive notifications of what Muse headbands
        // we can connect to.
        manager.setMuseListener(new MuseL(weakActivity));
=======
    public void startMuseManager() {
        // MuseManagerAndroid must be created and given context before any LibMuse calls can be made
        manager = MuseManagerAndroid.getInstance();
        manager.setContext(this.getReactApplicationContext());
        // Listeners are attached to a weak reference to the current activity to avoid memory leaks
>>>>>>> dano-signal-processing

        manager.setMuseListener(new MuseL());
        manager.startListening();
<<<<<<< HEAD
    }

    // Stops an ongoing getAndConnectToDevice function if no Muses are found
    public void noMusesDetected() {
        sendEvent(getReactApplicationContext(), "NO_MUSES", Arguments.createMap());
        stopConnector();
        connectionPromise.resolve(false);
    }
||||||| merged common ancestors
            }

    // Returns
    @ReactMethod
    public void getDevices(Promise promise) {
=======
    }
>>>>>>> dano-signal-processing

<<<<<<< HEAD
    // Posts a connectRunnable to connectHandler
    public void connectToMuse() {
        // Post is delayed to allow previous runAsynchrounously calls to complete
        connectHandler.postDelayed(connectRunnable, 100);
    }
||||||| merged common ancestors
        if (manager == null) {
            // We need to set the context on MuseManagerAndroid before we can do anything.
            // This must come before other LibMuse API calls as it also loads the library.
            manager = MuseManagerAndroid.getInstance();
            manager.setContext(this.getReactApplicationContext());
=======
    public void noMusesDetected() {
        sendEvent(getReactApplicationContext(), "NO_MUSES", Arguments.createMap());
        stopConnector();
        connectionPromise.resolve(false);
    }
>>>>>>> dano-signal-processing

<<<<<<< HEAD
    // Resolves getAndConnectToDevice promise and registers persistent connection listener
    public void museConnected() {
        connectionPromise.resolve(true);
        appState.connectedMuse = muse;
        stopConnector();
||||||| merged common ancestors
            // Clear the list of available muses so the user sees an empty list of devices when starting
            availableMuses = null;
=======
    public void connectToMuse() {
        Log.w(TAG, "connectToMuse called");
        connectHandler.post(connectRunnable);
    }
>>>>>>> dano-signal-processing

<<<<<<< HEAD
        // Connected Muses are stored in the MainApplication context so they can be accessed from anywhere in the app.
        appState = ((MainApplication)this.getCurrentActivity().getApplication());
||||||| merged common ancestors
            // Declare global application reference that is used for storing global Muse object
            appState = ((MainApplication)this.getCurrentActivity().getApplication());
=======
    public void museConnected() {
        Log.w(TAG, "museConnected");
        connectionPromise.resolve(true);
        appState.connectedMuse = muse;
        stopConnector();
>>>>>>> dano-signal-processing

<<<<<<< HEAD
        // Register connectionListener that will persist to handle disconnects
        // TODO: consider putting this on another thread or in a service
        connectionListener = new ConnectionListener();
        appState.connectedMuse.registerConnectionListener(connectionListener);
    }
||||||| merged common ancestors
            // Todo: figure out if weakReference is necessary or desirable. get currentActivity might be good enough
            WeakReference<Activity> weakActivity =
                    new WeakReference<Activity> (this.getCurrentActivity());
=======
        // Register connectionListener that will persist throughout app
        connectionListener = new ConnectionListener();
        appState.connectedMuse.registerConnectionListener(connectionListener);
    }
>>>>>>> dano-signal-processing

    // ------------------------------------------------------------------------------
    // Runnables

<<<<<<< HEAD
    // Searches for available Muses and puts app in NO_MUSE state if none are detected
    private final Runnable searchRunnable = new Runnable() {
        @Override
        public void run() {
            try {
                sendEvent(getReactApplicationContext(), "DISCONNECTED", Arguments.createMap());
                Thread.sleep(1500);
                availableMuses = manager.getMuses();
||||||| merged common ancestors
            // Register a listener to receive notifications of what Muse headbands
            // we can connect to.
            manager.setMuseListener(new MuseL(weakActivity));
            manager.startListening();
        }
        // Create WriteableArray that can be passed to JS
        // Change from ReadableMap to ReadableArray containing ReadableMaps
        WritableArray availableMuseArray = Arguments.createArray();
=======
    // Searches for available Muses and puts app in NO_MUSE state if none are detected
    private final Runnable searchRunnable = new Runnable() {
        @Override
        public void run() {
            try {

                availableMuses = manager.getMuses();
                Log.w(TAG, "Searching for Muses" + availableMuses);
                Thread.sleep(1000);
                if (availableMuses.isEmpty() || tryCount >= 4) {
                    noMusesDetected();
                }
            } catch ( InterruptedException e) { }
        }
    };
>>>>>>> dano-signal-processing

<<<<<<< HEAD

                if (availableMuses.isEmpty() || tryCount >= 4) {
                    noMusesDetected();
                }
            } catch ( InterruptedException e) { }
        }
    };

    // Attempts to connect by registering a connection Listener and calling runAsynchronously()
    private final Runnable connectRunnable = new Runnable() {
        @Override
        public void run() {
            try {
                sendEvent(getReactApplicationContext(), "CONNECT_ATTEMPT", Arguments.createMap());
                muse = availableMuses.get(museIndex);
                connectionListener = new ConnectionListener();

                // Unregister all prior listeners and register our ConnectionListener to the
                // Muse we are interested in. The ConnectionListener will allow us to detect
                // whether the connection attempt is successful
                muse.unregisterAllListeners();
                muse.registerConnectionListener(connectionListener);

                // Initiate a connection to the headband and stream the data asynchronously.
                // runAsynchronously() handles most of the work to connect to the Muse by itself
                muse.runAsynchronously();
            } catch (IllegalArgumentException | NullPointerException | IndexOutOfBoundsException e) {
                connectionPromise.reject(e);
                return;
            }
||||||| merged common ancestors
        availableMuses = manager.getMuses();

        try {
            // Add the name of each available Muse to an array that will be passed to JS
            for (Muse muse : availableMuses) {
                // key = MAC address, value = Muse Name
                availableMuseArray.pushString(muse.getName());
            }
            promise.resolve(availableMuseArray);
        } catch (IllegalViewOperationException e) {
            promise.reject(e);
        }
    }

    @ReactMethod
    public void connectDevice(Promise promise) {
        connectionPromise = promise;
        unfulfilledPromise = true;

        // If availableMuses list is empty
        if (availableMuses == null || availableMuses.size() == 0)  {

            return;
=======
    // Handles connection attempts. Allows connection to occur on a seperate thread so it doesn't slow down UI. Starts looping through available Muses, but should only be called once.
    private final Runnable connectRunnable = new Runnable() {
        @Override
        public void run() {
            try {
                sendEvent(getReactApplicationContext(), "CONNECT_ATTEMPT", Arguments.createMap());
                Log.w(TAG, "Attempting to connect to " + availableMuses.get(museIndex).getName());
                muse = availableMuses.get(museIndex);
                connectionListener = new ConnectionListener();

                // Unregister all prior listeners and register our ConnectionListener to the
                // Muse we are interested in. The ConnectionListener will allow us to detect
                // whether the connection attempt is successful
                muse.unregisterAllListeners();
                muse.registerConnectionListener(connectionListener);

                // Initiate a connection to the headband and stream the data asynchronously.
                // runAsynchronously() handles most of the work to connect to the Muse by itself
                muse.runAsynchronously();
            } catch (IllegalArgumentException | NullPointerException | IndexOutOfBoundsException e) {
                connectionPromise.reject(e);
                return;
            }
>>>>>>> dano-signal-processing
        }
    };

<<<<<<< HEAD
    // ---------------------------------------------------------
    // Thread management functions
||||||| merged common ancestors
        // set global Muse to first muse in availableMuses list
        appState.connectedMuse = availableMuses.get(0);

        // Unregister all prior listeners and register our data listener to
        // receive the MuseDataPacketTypes we are interested in.  If you do
        // not register a listener for a particular data type, you will not
        // receive data packets of that type.
        try {
            appState.connectedMuse.unregisterAllListeners();
            appState.connectedMuse.registerConnectionListener(connectionListener);
            manager.stopListening();

            // Initiate a connection to the headband and stream the data asynchronously.
            // runAsynchronously() bridges to a C++ function that is implemented on the Muse
            appState.connectedMuse.runAsynchronously();
        } catch (IllegalArgumentException | NullPointerException e) {

            connectionPromise.reject(e);
//            Toast.makeText(getCurrentActivity(), "No available muses", Toast.LENGTH_SHORT).show();
            return;
        }
    }
=======


    // ---------------------------------------------------------
    // Thread management functions

    // Start thread that will  update the data whenever a Muse data packet is received
>>>>>>> dano-signal-processing

    @ReactMethod
<<<<<<< HEAD
    // Stops all threads, managers, handlers, and listeners created in this module
    // Bridged so that it can be called from JS when user changes scenes
||||||| merged common ancestors
=======
    // Stops all threads, managers, handlers, and listeners created in this module
>>>>>>> dano-signal-processing
    public void stopConnector() {
<<<<<<< HEAD
        tryCount = 0;
||||||| merged common ancestors
=======
        Log.w(TAG, "Stopping connector");
        tryCount = 0;
>>>>>>> dano-signal-processing
        // It is important to call stopListening when the Activity is paused
        // to avoid a resource leak from the LibMuse library.
<<<<<<< HEAD
        if (manager != null) {
            manager.stopListening();
            manager = null;
        }

        isPromiseUnfulfilled = false;

        if (connectHandler != null) {
            connectHandler.removeCallbacks(connectRunnable);
            connectThread.quit();
        }
||||||| merged common ancestors
        manager.stopListening();

=======
        if (manager != null) {
            manager.stopListening();
            manager = null;
        }
        isPromiseUnfulfilled = false;
        if (connectHandler != null) {
            connectHandler.removeCallbacks(connectRunnable);
            connectThread.quit();
        }
>>>>>>> dano-signal-processing
        // Unregister listeners from connectMuse
        if (muse != null) {
            muse.unregisterAllListeners();
            muse = null;
        }
    }

    //--------------------------------------
    // Listeners

    // Detects available headbands and listens for changes to the list of Muses
    class MuseL extends MuseListener {

        MuseL() {
        }

        @Override
        public void museListChanged() {
<<<<<<< HEAD
            availableMuses = manager.getMuses();
||||||| merged common ancestors
=======
            Log.w(TAG, "New Muse added " + manager.getMuses());
            availableMuses = manager.getMuses();
>>>>>>> dano-signal-processing
        }
    }

    // Notified whenever connection state of its registered Muse changes
    class ConnectionListener extends MuseConnectionListener  {

        ConnectionListener() {
        }

        @Override
        public void receiveMuseConnectionPacket(final MuseConnectionPacket p, final Muse muse) {
            final ConnectionState current = p.getCurrentConnectionState();
<<<<<<< HEAD
            if (current == ConnectionState.CONNECTED) {
                sendEvent(getReactApplicationContext(), "CONNECTED", Arguments.createMap());
                if (isPromiseUnfulfilled){
                    museConnected();
                    return;
||||||| merged common ancestors

            // Code to resolve connectionPromise either true or false from connectDevice()
            // We only want this code to run if connectDevice() has just been triggered and the
            // promise is still pending
                if (current == ConnectionState.CONNECTED) {
                    sendEvent(getReactApplicationContext(), "CONNECTED", Arguments.createMap());
                    if (unfulfilledPromise){

                        connectionPromise.resolve(true);
                        unfulfilledPromise = false;
                    }
=======
            // Code to resolve connectionPromise either true or false from connectDevice()
            // We only want this code to run if connectDevice() has just been triggered and the
            // promise is still pending
                if (current == ConnectionState.CONNECTED) {
                    sendEvent(getReactApplicationContext(), "CONNECTED", Arguments.createMap());
                    if (isPromiseUnfulfilled){
                        museConnected();
                        return;
                    }
>>>>>>> dano-signal-processing
                }
            }

<<<<<<< HEAD
            // If persistent connectionListener detects disconnected state while there is no
            // unfulfilled promise (not in the midst of connection attempts), an event should be
            // dispatched to JS to prompt a return to the connection scene
            if (current == ConnectionState.DISCONNECTED) {
                sendEvent(getReactApplicationContext(), "DISCONNECTED", Arguments.createMap());

                // If disconnection is detected in midst of connection attempts (failure),
                // unregister all listeners, increment the index and try again with the next Muse.
                // If none of the Muses in availableMuses work, queue another search attempt, start
                // from the beginning and try again
                if (isPromiseUnfulfilled){
                    muse.unregisterAllListeners();
                    museIndex++;
                    tryCount++;
                    if(museIndex < availableMuses.size()) {
                        connectToMuse();
                    } else {
                        museIndex = 0;
                        connectHandler.post(searchRunnable);
                        connectToMuse();
||||||| merged common ancestors
                // If listener detects disconnected state while their is not unfulfilled promise,
                // an event should be dispatched to JS to return user to connection screen
                if (current == ConnectionState.DISCONNECTED) {
                    sendEvent(getReactApplicationContext(), "DISCONNECTED", Arguments.createMap());
                    if (unfulfilledPromise){
                        connectionPromise.resolve(false);
                        unfulfilledPromise = false;
=======
                // If listener detects disconnected state while their is not unfulfilled promise,
                // an event should be dispatched to JS to return user to connection screen
                if (current == ConnectionState.DISCONNECTED) {
                    sendEvent(getReactApplicationContext(), "DISCONNECTED", Arguments.createMap());
                    if (isPromiseUnfulfilled){
                        muse.unregisterAllListeners();
                        museIndex++;
                        tryCount++;
                        if(museIndex < availableMuses.size()) {
                            Log.w(TAG, "trying next muse in list");
                            connectToMuse();
                        } else {
                            Log.w(TAG, "none of the muses worked, trying again");
                            museIndex = 0;
                            connectHandler.post(searchRunnable);
                            connectToMuse();
                        }
>>>>>>> dano-signal-processing
                    }
                }
            }

        }
    }
}




